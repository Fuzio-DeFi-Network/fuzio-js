/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
	type FuzioStakingClient,
	type FuzioStakingQueryClient
} from "./FuzioStaking.client"
import {
	type Binary,
	type ConfigResponse,
	type Denom,
	type Schedule,
	type StakerInfoResponse,
	type StakersListResponse,
	type StateResponse,
	type Uint128,
	type UnbondingInfoResponse
} from "./FuzioStaking.types"
import {
	Addr,
	Cw20ReceiveMsg as Cw20ReceiveMessage,
	Decimal,
	ExecuteMsg as ExecuteMessage,
	InstantiateMsg as InstantiateMessage,
	QueryMsg as QueryMessage,
	StakerInfo,
	UnbondingInfo
} from "./FuzioStaking.types"
import { type Coin, type StdFee } from "@cosmjs/amino"
import { type ExecuteResult } from "@cosmjs/cosmwasm-stargate"
import {
	type UseMutationOptions,
	type UseQueryOptions
} from "@tanstack/react-query"
import { useMutation, useQuery } from "@tanstack/react-query"

export const fuzioStakingQueryKeys = {
	address: (contractAddress: string) =>
		[
			{ ...fuzioStakingQueryKeys.contract[0], address: contractAddress }
		] as const,
	allStakers: (contractAddress: string, args?: Record<string, unknown>) =>
		[
			{
				...fuzioStakingQueryKeys.address(contractAddress)[0],
				args,
				method: "all_stakers"
			}
		] as const,
	config: (contractAddress: string, args?: Record<string, unknown>) =>
		[
			{
				...fuzioStakingQueryKeys.address(contractAddress)[0],
				args,
				method: "config"
			}
		] as const,
	contract: [
		{
			contract: "fuzioStaking"
		}
	] as const,
	stakerInfo: (contractAddress: string, args?: Record<string, unknown>) =>
		[
			{
				...fuzioStakingQueryKeys.address(contractAddress)[0],
				args,
				method: "staker_info"
			}
		] as const,
	state: (contractAddress: string, args?: Record<string, unknown>) =>
		[
			{
				...fuzioStakingQueryKeys.address(contractAddress)[0],
				args,
				method: "state"
			}
		] as const,
	unbondingInfo: (contractAddress: string, args?: Record<string, unknown>) =>
		[
			{
				...fuzioStakingQueryKeys.address(contractAddress)[0],
				args,
				method: "unbonding_info"
			}
		] as const
}
export const fuzioStakingQueries = {
	allStakers: <TData = StakersListResponse>({
		client,
		args,
		options
	}: FuzioStakingAllStakersQuery<TData>): UseQueryOptions<
		StakersListResponse,
		Error,
		TData
	> => ({
		queryFn: async () =>
			await client.allStakers({
				limit: args.limit,
				startAfter: args.startAfter
			}),
		queryKey: fuzioStakingQueryKeys.allStakers(client?.contractAddress, args),
		...options,
		enabled:
			Boolean(client) &&
			(options?.enabled != undefined ? options.enabled : true)
	}),
	config: <TData = ConfigResponse>({
		client,
		options
	}: FuzioStakingConfigQuery<TData>): UseQueryOptions<
		ConfigResponse,
		Error,
		TData
	> => ({
		queryFn: async () => await client.config(),
		queryKey: fuzioStakingQueryKeys.config(client?.contractAddress),
		...options,
		enabled:
			Boolean(client) &&
			(options?.enabled != undefined ? options.enabled : true)
	}),
	stakerInfo: <TData = StakerInfoResponse>({
		client,
		args,
		options
	}: FuzioStakingStakerInfoQuery<TData>): UseQueryOptions<
		StakerInfoResponse,
		Error,
		TData
	> => ({
		queryFn: async () =>
			await client.stakerInfo({
				staker: args.staker
			}),
		queryKey: fuzioStakingQueryKeys.stakerInfo(client?.contractAddress, args),
		...options,
		enabled:
			Boolean(client) &&
			(options?.enabled != undefined ? options.enabled : true)
	}),
	state: <TData = StateResponse>({
		client,
		args,
		options
	}: FuzioStakingStateQuery<TData>): UseQueryOptions<
		StateResponse,
		Error,
		TData
	> => ({
		queryFn: async () =>
			await client.state({
				blockTime: args.blockTime
			}),
		queryKey: fuzioStakingQueryKeys.state(client?.contractAddress, args),
		...options,
		enabled:
			Boolean(client) &&
			(options?.enabled != undefined ? options.enabled : true)
	}),
	unbondingInfo: <TData = UnbondingInfoResponse>({
		client,
		args,
		options
	}: FuzioStakingUnbondingInfoQuery<TData>): UseQueryOptions<
		UnbondingInfoResponse,
		Error,
		TData
	> => ({
		queryFn: async () =>
			await client.unbondingInfo({
				limit: args.limit,
				staker: args.staker,
				startAfter: args.startAfter
			}),
		queryKey: fuzioStakingQueryKeys.unbondingInfo(
			client?.contractAddress,
			args
		),
		...options,
		enabled:
			Boolean(client) &&
			(options?.enabled != undefined ? options.enabled : true)
	})
}
export type FuzioStakingReactQuery<TResponse, TData = TResponse> = {
	client: FuzioStakingQueryClient
	options?: Omit<
		UseQueryOptions<TResponse, Error, TData>,
		"'queryKey' | 'queryFn' | 'initialData'"
	> & {
		initialData?: undefined
	}
}
export type FuzioStakingUnbondingInfoQuery<TData> = FuzioStakingReactQuery<
	UnbondingInfoResponse,
	TData
> & {
	args: {
		limit?: number
		staker: string
		startAfter?: number
	}
}
export function useFuzioStakingUnbondingInfoQuery<
	TData = UnbondingInfoResponse
>({ client, args, options }: FuzioStakingUnbondingInfoQuery<TData>) {
	return useQuery<UnbondingInfoResponse, Error, TData>(
		fuzioStakingQueryKeys.unbondingInfo(client.contractAddress, args),
		async () =>
			await client.unbondingInfo({
				limit: args.limit,
				staker: args.staker,
				startAfter: args.startAfter
			}),
		options
	)
}

export type FuzioStakingAllStakersQuery<TData> = FuzioStakingReactQuery<
	StakersListResponse,
	TData
> & {
	args: {
		limit?: number
		startAfter?: string
	}
}
export function useFuzioStakingAllStakersQuery<TData = StakersListResponse>({
	client,
	args,
	options
}: FuzioStakingAllStakersQuery<TData>) {
	return useQuery<StakersListResponse, Error, TData>(
		fuzioStakingQueryKeys.allStakers(client.contractAddress, args),
		async () =>
			await client.allStakers({
				limit: args.limit,
				startAfter: args.startAfter
			}),
		options
	)
}

export type FuzioStakingStakerInfoQuery<TData> = FuzioStakingReactQuery<
	StakerInfoResponse,
	TData
> & {
	args: {
		staker: string
	}
}
export function useFuzioStakingStakerInfoQuery<TData = StakerInfoResponse>({
	client,
	args,
	options
}: FuzioStakingStakerInfoQuery<TData>) {
	return useQuery<StakerInfoResponse, Error, TData>(
		fuzioStakingQueryKeys.stakerInfo(client.contractAddress, args),
		async () =>
			await client.stakerInfo({
				staker: args.staker
			}),
		options
	)
}

export type FuzioStakingStateQuery<TData> = FuzioStakingReactQuery<
	StateResponse,
	TData
> & {
	args: {
		blockTime?: number
	}
}
export function useFuzioStakingStateQuery<TData = StateResponse>({
	client,
	args,
	options
}: FuzioStakingStateQuery<TData>) {
	return useQuery<StateResponse, Error, TData>(
		fuzioStakingQueryKeys.state(client.contractAddress, args),
		async () =>
			await client.state({
				blockTime: args.blockTime
			}),
		options
	)
}

export type FuzioStakingConfigQuery<TData> = FuzioStakingReactQuery<
	ConfigResponse,
	TData
> & {}
export function useFuzioStakingConfigQuery<TData = ConfigResponse>({
	client,
	options
}: FuzioStakingConfigQuery<TData>) {
	return useQuery<ConfigResponse, Error, TData>(
		fuzioStakingQueryKeys.config(client.contractAddress),
		async () => await client.config(),
		options
	)
}

export type FuzioStakingUpdateLockDurationMutation = {
	args?: {
		fee?: StdFee | number | "auto"
		funds?: Coin[]
		memo?: string
	}
	client: FuzioStakingClient
	msg: {
		lockDuration: number
	}
}
export function useFuzioStakingUpdateLockDurationMutation(
	options?: Omit<
		UseMutationOptions<
			ExecuteResult,
			Error,
			FuzioStakingUpdateLockDurationMutation
		>,
		"mutationFn"
	>
) {
	return useMutation<
		ExecuteResult,
		Error,
		FuzioStakingUpdateLockDurationMutation
	>(
		({ client, msg, args: { fee, memo, funds } = {} }) =>
			client.updateLockDuration(msg, fee, memo, funds),
		options
	)
}

export type FuzioStakingUpdateTokensAndDistributionMutation = {
	args?: {
		fee?: StdFee | number | "auto"
		funds?: Coin[]
		memo?: string
	}
	client: FuzioStakingClient
	msg: {
		distributionSchedule: Schedule[]
		lpTokenContract: string
		rewardToken: Denom[]
	}
}
export function useFuzioStakingUpdateTokensAndDistributionMutation(
	options?: Omit<
		UseMutationOptions<
			ExecuteResult,
			Error,
			FuzioStakingUpdateTokensAndDistributionMutation
		>,
		"mutationFn"
	>
) {
	return useMutation<
		ExecuteResult,
		Error,
		FuzioStakingUpdateTokensAndDistributionMutation
	>(
		({ client, msg, args: { fee, memo, funds } = {} }) =>
			client.updateTokensAndDistribution(msg, fee, memo, funds),
		options
	)
}

export type FuzioStakingUpdateTokenContractMutation = {
	args?: {
		fee?: StdFee | number | "auto"
		funds?: Coin[]
		memo?: string
	}
	client: FuzioStakingClient
	msg: {
		lpTokenContract: string
		rewardToken: Denom[]
	}
}
export function useFuzioStakingUpdateTokenContractMutation(
	options?: Omit<
		UseMutationOptions<
			ExecuteResult,
			Error,
			FuzioStakingUpdateTokenContractMutation
		>,
		"mutationFn"
	>
) {
	return useMutation<
		ExecuteResult,
		Error,
		FuzioStakingUpdateTokenContractMutation
	>(
		({ client, msg, args: { fee, memo, funds } = {} }) =>
			client.updateTokenContract(msg, fee, memo, funds),
		options
	)
}

export type FuzioStakingUpdateConfigMutation = {
	args?: {
		fee?: StdFee | number | "auto"
		funds?: Coin[]
		memo?: string
	}
	client: FuzioStakingClient
	msg: {
		distributionSchedule: Schedule[]
	}
}
export function useFuzioStakingUpdateConfigMutation(
	options?: Omit<
		UseMutationOptions<ExecuteResult, Error, FuzioStakingUpdateConfigMutation>,
		"mutationFn"
	>
) {
	return useMutation<ExecuteResult, Error, FuzioStakingUpdateConfigMutation>(
		({ client, msg, args: { fee, memo, funds } = {} }) =>
			client.updateConfig(msg, fee, memo, funds),
		options
	)
}

export type FuzioStakingUpdateAdminMutation = {
	args?: {
		fee?: StdFee | number | "auto"
		funds?: Coin[]
		memo?: string
	}
	client: FuzioStakingClient
	msg: {
		admin: string
	}
}
export function useFuzioStakingUpdateAdminMutation(
	options?: Omit<
		UseMutationOptions<ExecuteResult, Error, FuzioStakingUpdateAdminMutation>,
		"mutationFn"
	>
) {
	return useMutation<ExecuteResult, Error, FuzioStakingUpdateAdminMutation>(
		({ client, msg, args: { fee, memo, funds } = {} }) =>
			client.updateAdmin(msg, fee, memo, funds),
		options
	)
}

export type FuzioStakingRedeemMutation = {
	args?: {
		fee?: StdFee | number | "auto"
		funds?: Coin[]
		memo?: string
	}
	client: FuzioStakingClient
}
export function useFuzioStakingRedeemMutation(
	options?: Omit<
		UseMutationOptions<ExecuteResult, Error, FuzioStakingRedeemMutation>,
		"mutationFn"
	>
) {
	return useMutation<ExecuteResult, Error, FuzioStakingRedeemMutation>(
		({ client, args: { fee, memo, funds } = {} }) =>
			client.redeem(fee, memo, funds),
		options
	)
}

export type FuzioStakingWithdrawMutation = {
	args?: {
		fee?: StdFee | number | "auto"
		funds?: Coin[]
		memo?: string
	}
	client: FuzioStakingClient
}
export function useFuzioStakingWithdrawMutation(
	options?: Omit<
		UseMutationOptions<ExecuteResult, Error, FuzioStakingWithdrawMutation>,
		"mutationFn"
	>
) {
	return useMutation<ExecuteResult, Error, FuzioStakingWithdrawMutation>(
		({ client, args: { fee, memo, funds } = {} }) =>
			client.withdraw(fee, memo, funds),
		options
	)
}

export type FuzioStakingUnbondMutation = {
	args?: {
		fee?: StdFee | number | "auto"
		funds?: Coin[]
		memo?: string
	}
	client: FuzioStakingClient
	msg: {
		amount: Uint128
	}
}
export function useFuzioStakingUnbondMutation(
	options?: Omit<
		UseMutationOptions<ExecuteResult, Error, FuzioStakingUnbondMutation>,
		"mutationFn"
	>
) {
	return useMutation<ExecuteResult, Error, FuzioStakingUnbondMutation>(
		({ client, msg, args: { fee, memo, funds } = {} }) =>
			client.unbond(msg, fee, memo, funds),
		options
	)
}

export type FuzioStakingReceiveMutation = {
	args?: {
		fee?: StdFee | number | "auto"
		funds?: Coin[]
		memo?: string
	}
	client: FuzioStakingClient
	msg: {
		amount: Uint128
		msg: Binary
		sender: string
	}
}
export function useFuzioStakingReceiveMutation(
	options?: Omit<
		UseMutationOptions<ExecuteResult, Error, FuzioStakingReceiveMutation>,
		"mutationFn"
	>
) {
	return useMutation<ExecuteResult, Error, FuzioStakingReceiveMutation>(
		({ client, msg, args: { fee, memo, funds } = {} }) =>
			client.receive(msg, fee, memo, funds),
		options
	)
}
