/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { UseQueryOptions, useQuery, useMutation, UseMutationOptions } from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import { Decimal, Uint128, Denom, Addr, InstantiateMsg, WalletInfo, ExecuteMsg, Expiration, Timestamp, Uint64, TokenSelect, QueryMsg, MigrateMsg, FeeResponse, InfoResponse, Token1ForToken2PriceResponse, Token2ForToken1PriceResponse } from "./FuzioPool.types";
import { FuzioPoolQueryClient, FuzioPoolClient } from "./FuzioPool.client";
export const fuzioPoolQueryKeys = {
  contract: ([{
    contract: "fuzioPool"
  }] as const),
  address: (contractAddress: string) => ([{ ...fuzioPoolQueryKeys.contract[0],
    address: contractAddress
  }] as const),
  info: (contractAddress: string, args?: Record<string, unknown>) => ([{ ...fuzioPoolQueryKeys.address(contractAddress)[0],
    method: "info",
    args
  }] as const),
  token1ForToken2Price: (contractAddress: string, args?: Record<string, unknown>) => ([{ ...fuzioPoolQueryKeys.address(contractAddress)[0],
    method: "token1_for_token2_price",
    args
  }] as const),
  token2ForToken1Price: (contractAddress: string, args?: Record<string, unknown>) => ([{ ...fuzioPoolQueryKeys.address(contractAddress)[0],
    method: "token2_for_token1_price",
    args
  }] as const),
  fee: (contractAddress: string, args?: Record<string, unknown>) => ([{ ...fuzioPoolQueryKeys.address(contractAddress)[0],
    method: "fee",
    args
  }] as const)
};
export const fuzioPoolQueries = {
  info: <TData = InfoResponse,>({
    client,
    options
  }: FuzioPoolInfoQuery<TData>): UseQueryOptions<InfoResponse, Error, TData> => ({
    queryKey: fuzioPoolQueryKeys.info(client?.contractAddress),
    queryFn: () => client.info(),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  token1ForToken2Price: <TData = Token1ForToken2PriceResponse,>({
    client,
    args,
    options
  }: FuzioPoolToken1ForToken2PriceQuery<TData>): UseQueryOptions<Token1ForToken2PriceResponse, Error, TData> => ({
    queryKey: fuzioPoolQueryKeys.token1ForToken2Price(client?.contractAddress, args),
    queryFn: () => client.token1ForToken2Price({
      token1Amount: args.token1Amount
    }),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  token2ForToken1Price: <TData = Token2ForToken1PriceResponse,>({
    client,
    args,
    options
  }: FuzioPoolToken2ForToken1PriceQuery<TData>): UseQueryOptions<Token2ForToken1PriceResponse, Error, TData> => ({
    queryKey: fuzioPoolQueryKeys.token2ForToken1Price(client?.contractAddress, args),
    queryFn: () => client.token2ForToken1Price({
      token2Amount: args.token2Amount
    }),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  }),
  fee: <TData = FeeResponse,>({
    client,
    options
  }: FuzioPoolFeeQuery<TData>): UseQueryOptions<FeeResponse, Error, TData> => ({
    queryKey: fuzioPoolQueryKeys.fee(client?.contractAddress),
    queryFn: () => client.fee(),
    ...options,
    enabled: !!client && (options?.enabled != undefined ? options.enabled : true)
  })
};
export interface FuzioPoolReactQuery<TResponse, TData = TResponse> {
  client: FuzioPoolQueryClient;
  options?: Omit<UseQueryOptions<TResponse, Error, TData>, "'queryKey' | 'queryFn' | 'initialData'"> & {
    initialData?: undefined;
  };
}
export interface FuzioPoolFeeQuery<TData> extends FuzioPoolReactQuery<FeeResponse, TData> {}
export function useFuzioPoolFeeQuery<TData = FeeResponse>({
  client,
  options
}: FuzioPoolFeeQuery<TData>) {
  return useQuery<FeeResponse, Error, TData>(fuzioPoolQueryKeys.fee(client.contractAddress), () => client.fee(), options);
}
export interface FuzioPoolToken2ForToken1PriceQuery<TData> extends FuzioPoolReactQuery<Token2ForToken1PriceResponse, TData> {
  args: {
    token2Amount: Uint128;
  };
}
export function useFuzioPoolToken2ForToken1PriceQuery<TData = Token2ForToken1PriceResponse>({
  client,
  args,
  options
}: FuzioPoolToken2ForToken1PriceQuery<TData>) {
  return useQuery<Token2ForToken1PriceResponse, Error, TData>(fuzioPoolQueryKeys.token2ForToken1Price(client.contractAddress, args), () => client.token2ForToken1Price({
    token2Amount: args.token2Amount
  }), options);
}
export interface FuzioPoolToken1ForToken2PriceQuery<TData> extends FuzioPoolReactQuery<Token1ForToken2PriceResponse, TData> {
  args: {
    token1Amount: Uint128;
  };
}
export function useFuzioPoolToken1ForToken2PriceQuery<TData = Token1ForToken2PriceResponse>({
  client,
  args,
  options
}: FuzioPoolToken1ForToken2PriceQuery<TData>) {
  return useQuery<Token1ForToken2PriceResponse, Error, TData>(fuzioPoolQueryKeys.token1ForToken2Price(client.contractAddress, args), () => client.token1ForToken2Price({
    token1Amount: args.token1Amount
  }), options);
}
export interface FuzioPoolInfoQuery<TData> extends FuzioPoolReactQuery<InfoResponse, TData> {}
export function useFuzioPoolInfoQuery<TData = InfoResponse>({
  client,
  options
}: FuzioPoolInfoQuery<TData>) {
  return useQuery<InfoResponse, Error, TData>(fuzioPoolQueryKeys.info(client.contractAddress), () => client.info(), options);
}
export interface FuzioPoolUpdateConfigMutation {
  client: FuzioPoolClient;
  msg: {
    devWalletLists: WalletInfo[];
    feePercentDenominator: Uint128;
    feePercentNumerator: Uint128;
    owner?: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useFuzioPoolUpdateConfigMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, FuzioPoolUpdateConfigMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, FuzioPoolUpdateConfigMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.updateConfig(msg, fee, memo, funds), options);
}
export interface FuzioPoolSwapAndSendToMutation {
  client: FuzioPoolClient;
  msg: {
    expiration?: Expiration;
    inputAmount: Uint128;
    inputToken: TokenSelect;
    minToken: Uint128;
    recipient: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useFuzioPoolSwapAndSendToMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, FuzioPoolSwapAndSendToMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, FuzioPoolSwapAndSendToMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.swapAndSendTo(msg, fee, memo, funds), options);
}
export interface FuzioPoolPassThroughSwapMutation {
  client: FuzioPoolClient;
  msg: {
    expiration?: Expiration;
    inputToken: TokenSelect;
    inputTokenAmount: Uint128;
    outputAmmAddress: string;
    outputMinToken: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useFuzioPoolPassThroughSwapMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, FuzioPoolPassThroughSwapMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, FuzioPoolPassThroughSwapMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.passThroughSwap(msg, fee, memo, funds), options);
}
export interface FuzioPoolSwapMutation {
  client: FuzioPoolClient;
  msg: {
    expiration?: Expiration;
    inputAmount: Uint128;
    inputToken: TokenSelect;
    minOutput: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useFuzioPoolSwapMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, FuzioPoolSwapMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, FuzioPoolSwapMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.swap(msg, fee, memo, funds), options);
}
export interface FuzioPoolRemoveLiquidityMutation {
  client: FuzioPoolClient;
  msg: {
    amount: Uint128;
    expiration?: Expiration;
    minToken1: Uint128;
    minToken2: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useFuzioPoolRemoveLiquidityMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, FuzioPoolRemoveLiquidityMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, FuzioPoolRemoveLiquidityMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.removeLiquidity(msg, fee, memo, funds), options);
}
export interface FuzioPoolAddLiquidityMutation {
  client: FuzioPoolClient;
  msg: {
    expiration?: Expiration;
    maxToken2: Uint128;
    minLiquidity: Uint128;
    token1Amount: Uint128;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useFuzioPoolAddLiquidityMutation(options?: Omit<UseMutationOptions<ExecuteResult, Error, FuzioPoolAddLiquidityMutation>, "mutationFn">) {
  return useMutation<ExecuteResult, Error, FuzioPoolAddLiquidityMutation>(({
    client,
    msg,
    args: {
      fee,
      memo,
      funds
    } = {}
  }) => client.addLiquidity(msg, fee, memo, funds), options);
}