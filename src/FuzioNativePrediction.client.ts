/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.3.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Addr, Decimal, Uint128, InstantiateMsg, Config, WalletInfo, ExecuteMsg, QueryMsg, MigrateMsg, Timestamp, Uint64, Direction, FinishedRound, AdminsResponse, ClaimInfoResponse, ClaimInfo, RoundUsersResponse, BetInfo, MyCurrentPositionResponse, MyGameResponse, PendingRewardResponse, PendingRewardRoundsResponse, StatusResponse, NextRound, LiveRound, TotalSpentResponse } from "./FuzioNativePrediction.types";
export interface FuzioNativePredictionReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<Config>;
  status: () => Promise<StatusResponse>;
  myCurrentPosition: ({
    address
  }: {
    address: string;
  }) => Promise<MyCurrentPositionResponse>;
  finishedRound: ({
    roundId
  }: {
    roundId: Uint128;
  }) => Promise<FinishedRound>;
  myGameList: ({
    limit,
    player,
    startAfter
  }: {
    limit?: number;
    player: Addr;
    startAfter?: Uint128;
  }) => Promise<MyGameResponse>;
  myPendingReward: ({
    player
  }: {
    player: Addr;
  }) => Promise<PendingRewardResponse>;
  myPendingRewardRounds: ({
    player
  }: {
    player: Addr;
  }) => Promise<PendingRewardRoundsResponse>;
  getUsersPerRound: ({
    limit,
    roundId,
    startAfter
  }: {
    limit?: number;
    roundId: Uint128;
    startAfter?: Addr;
  }) => Promise<RoundUsersResponse>;
  myPendingRewardRound: ({
    player,
    roundId
  }: {
    player: Addr;
    roundId: Uint128;
  }) => Promise<PendingRewardResponse>;
  getClaimInfoPerRound: ({
    limit,
    roundId,
    startAfter
  }: {
    limit?: number;
    roundId: Uint128;
    startAfter?: Addr;
  }) => Promise<ClaimInfoResponse>;
  getClaimInfoByUser: ({
    limit,
    player,
    startAfter
  }: {
    limit?: number;
    player: Addr;
    startAfter?: Uint128;
  }) => Promise<ClaimInfoResponse>;
  totalSpent: ({
    player
  }: {
    player: Addr;
  }) => Promise<TotalSpentResponse>;
  getAdmins: () => Promise<AdminsResponse>;
}
export class FuzioNativePredictionQueryClient implements FuzioNativePredictionReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.status = this.status.bind(this);
    this.myCurrentPosition = this.myCurrentPosition.bind(this);
    this.finishedRound = this.finishedRound.bind(this);
    this.myGameList = this.myGameList.bind(this);
    this.myPendingReward = this.myPendingReward.bind(this);
    this.myPendingRewardRounds = this.myPendingRewardRounds.bind(this);
    this.getUsersPerRound = this.getUsersPerRound.bind(this);
    this.myPendingRewardRound = this.myPendingRewardRound.bind(this);
    this.getClaimInfoPerRound = this.getClaimInfoPerRound.bind(this);
    this.getClaimInfoByUser = this.getClaimInfoByUser.bind(this);
    this.totalSpent = this.totalSpent.bind(this);
    this.getAdmins = this.getAdmins.bind(this);
  }

  config = async (): Promise<Config> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  status = async (): Promise<StatusResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      status: {}
    });
  };
  myCurrentPosition = async ({
    address
  }: {
    address: string;
  }): Promise<MyCurrentPositionResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      my_current_position: {
        address
      }
    });
  };
  finishedRound = async ({
    roundId
  }: {
    roundId: Uint128;
  }): Promise<FinishedRound> => {
    return this.client.queryContractSmart(this.contractAddress, {
      finished_round: {
        round_id: roundId
      }
    });
  };
  myGameList = async ({
    limit,
    player,
    startAfter
  }: {
    limit?: number;
    player: Addr;
    startAfter?: Uint128;
  }): Promise<MyGameResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      my_game_list: {
        limit,
        player,
        start_after: startAfter
      }
    });
  };
  myPendingReward = async ({
    player
  }: {
    player: Addr;
  }): Promise<PendingRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      my_pending_reward: {
        player
      }
    });
  };
  myPendingRewardRounds = async ({
    player
  }: {
    player: Addr;
  }): Promise<PendingRewardRoundsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      my_pending_reward_rounds: {
        player
      }
    });
  };
  getUsersPerRound = async ({
    limit,
    roundId,
    startAfter
  }: {
    limit?: number;
    roundId: Uint128;
    startAfter?: Addr;
  }): Promise<RoundUsersResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_users_per_round: {
        limit,
        round_id: roundId,
        start_after: startAfter
      }
    });
  };
  myPendingRewardRound = async ({
    player,
    roundId
  }: {
    player: Addr;
    roundId: Uint128;
  }): Promise<PendingRewardResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      my_pending_reward_round: {
        player,
        round_id: roundId
      }
    });
  };
  getClaimInfoPerRound = async ({
    limit,
    roundId,
    startAfter
  }: {
    limit?: number;
    roundId: Uint128;
    startAfter?: Addr;
  }): Promise<ClaimInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_claim_info_per_round: {
        limit,
        round_id: roundId,
        start_after: startAfter
      }
    });
  };
  getClaimInfoByUser = async ({
    limit,
    player,
    startAfter
  }: {
    limit?: number;
    player: Addr;
    startAfter?: Uint128;
  }): Promise<ClaimInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_claim_info_by_user: {
        limit,
        player,
        start_after: startAfter
      }
    });
  };
  totalSpent = async ({
    player
  }: {
    player: Addr;
  }): Promise<TotalSpentResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      total_spent: {
        player
      }
    });
  };
  getAdmins = async (): Promise<AdminsResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_admins: {}
    });
  };
}
export interface FuzioNativePredictionInterface {
  contractAddress: string;
  sender: string;
  updateConfig: ({
    config
  }: {
    config: Config;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  betBull: ({
    amount,
    roundId
  }: {
    amount: Uint128;
    roundId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  betBear: ({
    amount,
    roundId
  }: {
    amount: Uint128;
    roundId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  closeRound: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  collectWinnings: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  collectionWinningRound: ({
    roundId
  }: {
    roundId: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  halt: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  resume: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  addAdmin: ({
    newAdmin
  }: {
    newAdmin: Addr;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  removeAdmin: ({
    oldAdmin
  }: {
    oldAdmin: Addr;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  modifyDevWallet: ({
    newDevWallets
  }: {
    newDevWallets: WalletInfo[];
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class FuzioNativePredictionClient implements FuzioNativePredictionInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.updateConfig = this.updateConfig.bind(this);
    this.betBull = this.betBull.bind(this);
    this.betBear = this.betBear.bind(this);
    this.closeRound = this.closeRound.bind(this);
    this.collectWinnings = this.collectWinnings.bind(this);
    this.collectionWinningRound = this.collectionWinningRound.bind(this);
    this.halt = this.halt.bind(this);
    this.resume = this.resume.bind(this);
    this.addAdmin = this.addAdmin.bind(this);
    this.removeAdmin = this.removeAdmin.bind(this);
    this.modifyDevWallet = this.modifyDevWallet.bind(this);
  }

  updateConfig = async ({
    config
  }: {
    config: Config;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        config
      }
    }, fee, memo, _funds);
  };
  betBull = async ({
    amount,
    roundId
  }: {
    amount: Uint128;
    roundId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bet_bull: {
        amount,
        round_id: roundId
      }
    }, fee, memo, _funds);
  };
  betBear = async ({
    amount,
    roundId
  }: {
    amount: Uint128;
    roundId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      bet_bear: {
        amount,
        round_id: roundId
      }
    }, fee, memo, _funds);
  };
  closeRound = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      close_round: {}
    }, fee, memo, _funds);
  };
  collectWinnings = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      collect_winnings: {}
    }, fee, memo, _funds);
  };
  collectionWinningRound = async ({
    roundId
  }: {
    roundId: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      collection_winning_round: {
        round_id: roundId
      }
    }, fee, memo, _funds);
  };
  halt = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      halt: {}
    }, fee, memo, _funds);
  };
  resume = async (fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      resume: {}
    }, fee, memo, _funds);
  };
  addAdmin = async ({
    newAdmin
  }: {
    newAdmin: Addr;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_admin: {
        new_admin: newAdmin
      }
    }, fee, memo, _funds);
  };
  removeAdmin = async ({
    oldAdmin
  }: {
    oldAdmin: Addr;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      remove_admin: {
        old_admin: oldAdmin
      }
    }, fee, memo, _funds);
  };
  modifyDevWallet = async ({
    newDevWallets
  }: {
    newDevWallets: WalletInfo[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      modify_dev_wallet: {
        new_dev_wallets: newDevWallets
      }
    }, fee, memo, _funds);
  };
}