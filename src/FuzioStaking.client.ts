/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.28.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Uint128, Denom, Addr, InstantiateMsg, ExecuteMsg, Binary, Cw20ReceiveMsg, QueryMsg, Decimal, StakersListResponse, StakerInfo, ConfigResponse, StakerInfoResponse, StateResponse, UnbondingInfoResponse, UnbondingInfo } from "./FuzioStaking.types";
export interface FuzioStakingReadOnlyInterface {
  contractAddress: string;
  config: () => Promise<ConfigResponse>;
  state: ({
    blockTime
  }: {
    blockTime?: number;
  }) => Promise<StateResponse>;
  stakerInfo: ({
    staker
  }: {
    staker: string;
  }) => Promise<StakerInfoResponse>;
  allStakers: ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }) => Promise<StakersListResponse>;
  unbondingInfo: ({
    limit,
    staker,
    startAfter
  }: {
    limit?: number;
    staker: string;
    startAfter?: number;
  }) => Promise<UnbondingInfoResponse>;
}
export class FuzioStakingQueryClient implements FuzioStakingReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.config = this.config.bind(this);
    this.state = this.state.bind(this);
    this.stakerInfo = this.stakerInfo.bind(this);
    this.allStakers = this.allStakers.bind(this);
    this.unbondingInfo = this.unbondingInfo.bind(this);
  }

  config = async (): Promise<ConfigResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      config: {}
    });
  };
  state = async ({
    blockTime
  }: {
    blockTime?: number;
  }): Promise<StateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      state: {
        block_time: blockTime
      }
    });
  };
  stakerInfo = async ({
    staker
  }: {
    staker: string;
  }): Promise<StakerInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      staker_info: {
        staker
      }
    });
  };
  allStakers = async ({
    limit,
    startAfter
  }: {
    limit?: number;
    startAfter?: string;
  }): Promise<StakersListResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      all_stakers: {
        limit,
        start_after: startAfter
      }
    });
  };
  unbondingInfo = async ({
    limit,
    staker,
    startAfter
  }: {
    limit?: number;
    staker: string;
    startAfter?: number;
  }): Promise<UnbondingInfoResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      unbonding_info: {
        limit,
        staker,
        start_after: startAfter
      }
    });
  };
}
export interface FuzioStakingInterface extends FuzioStakingReadOnlyInterface {
  contractAddress: string;
  sender: string;
  receive: ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  unbond: ({
    amount
  }: {
    amount: Uint128;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  withdraw: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  redeem: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateConfig: ({
    distributionSchedule
  }: {
    distributionSchedule: number[][][];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateAdmin: ({
    admin
  }: {
    admin: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateTokenContract: ({
    lpTokenContract,
    rewardToken
  }: {
    lpTokenContract: string;
    rewardToken: Denom[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  updateLockDuration: ({
    lockDuration
  }: {
    lockDuration: number;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class FuzioStakingClient extends FuzioStakingQueryClient implements FuzioStakingInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.receive = this.receive.bind(this);
    this.unbond = this.unbond.bind(this);
    this.withdraw = this.withdraw.bind(this);
    this.redeem = this.redeem.bind(this);
    this.updateConfig = this.updateConfig.bind(this);
    this.updateAdmin = this.updateAdmin.bind(this);
    this.updateTokenContract = this.updateTokenContract.bind(this);
    this.updateLockDuration = this.updateLockDuration.bind(this);
  }

  receive = async ({
    amount,
    msg,
    sender
  }: {
    amount: Uint128;
    msg: Binary;
    sender: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      receive: {
        amount,
        msg,
        sender
      }
    }, fee, memo, funds);
  };
  unbond = async ({
    amount
  }: {
    amount: Uint128;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      unbond: {
        amount
      }
    }, fee, memo, funds);
  };
  withdraw = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      withdraw: {}
    }, fee, memo, funds);
  };
  redeem = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      redeem: {}
    }, fee, memo, funds);
  };
  updateConfig = async ({
    distributionSchedule
  }: {
    distributionSchedule: number[][][];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_config: {
        distribution_schedule: distributionSchedule
      }
    }, fee, memo, funds);
  };
  updateAdmin = async ({
    admin
  }: {
    admin: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_admin: {
        admin
      }
    }, fee, memo, funds);
  };
  updateTokenContract = async ({
    lpTokenContract,
    rewardToken
  }: {
    lpTokenContract: string;
    rewardToken: Denom[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_token_contract: {
        lp_token_contract: lpTokenContract,
        reward_token: rewardToken
      }
    }, fee, memo, funds);
  };
  updateLockDuration = async ({
    lockDuration
  }: {
    lockDuration: number;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      update_lock_duration: {
        lock_duration: lockDuration
      }
    }, fee, memo, funds);
  };
}